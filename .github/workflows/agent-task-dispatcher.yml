name: Agent Task Dispatcher

on:
  workflow_dispatch:
    inputs:
      parent_issue:
        description: 'Parent issue number'
        required: true
        type: number
      trigger:
        description: 'Trigger reason'
        required: false
        type: string
        default: 'manual'

permissions:
  contents: read
  issues: write

jobs:
  dispatch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm install js-yaml @octokit/rest

      - name: Dispatch next task
        uses: actions/github-script@v7
        env:
          AGENT_GH_TOKEN: ${{ secrets.AGENT_GH_TOKEN }}
        with:
          github-token: ${{ secrets.AGENT_GH_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const issueNumber = parseInt('${{ inputs.parent_issue }}');
            
            const config = yaml.load(fs.readFileSync('.github/agent/config.yml', 'utf8'));
            
            const stateMarker = config.state.marker;
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100
            });
            
            const stateComments = comments
              .filter(c => c.body?.includes(stateMarker))
              .map(c => {
                try {
                  const jsonMatch = c.body?.match(/```json\n([\s\S]*?)\n```/);
                  if (jsonMatch) {
                    return JSON.parse(jsonMatch[1]);
                  }
                } catch (e) {
                  core.warning(`Failed to parse state: ${e}`);
                }
                return null;
              })
              .filter(s => s !== null);
            
            if (stateComments.length === 0) {
              core.setFailed('No state found for parent issue');
              return;
            }
            
            stateComments.sort((a, b) => b.version - a.version);
            const state = stateComments[0];
            
            if (state.paused) {
              core.info('â¸ï¸ Dispatch paused');
              return;
            }
            
            const planPath = `${config.paths.plan_yaml_dir}/issue-${issueNumber}.yaml`;
            if (!fs.existsSync(planPath)) {
              core.setFailed(`Plan file not found: ${planPath}`);
              return;
            }
            
            const plan = yaml.load(fs.readFileSync(planPath, 'utf8'));
            
            const inProgressTasks = plan.tasks.filter(t => t.status === 'in-progress');
            if (inProgressTasks.length > 0) {
              core.info(`â³ Task ${inProgressTasks[0].id} is already in progress`);
              return;
            }
               const pendingTasks = plan.tasks.filter(t => t.status === 'pending');
            if (pendingTasks.length === 0) {
              core.info('âœ… All tasks completed');
              
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                name: config.labels.parent.executing
              }).catch(() => {});
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: [config.labels.parent.done]
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `ðŸŽ‰ **All Tasks Completed**\n\nAll tasks have been successfully completed and merged.\n\n**Status:** \`done\``
              });
              
              return;
            }
            
            const nextTask = pendingTasks[0];
            
            const depsSatisfied = nextTask.deps.every(depId => {
              const depTask = plan.tasks.find(t => t.id === depId);
              return depTask && depTask.status === 'done';
            });
            
            if (!depsSatisfied) {
              core.info(`â³ Task ${nextTask.id} waiting for dependencies`);
              return;
            }
            
            if (!nextTask.issue) {
              core.setFailed(`Task ${nextTask.id} has no associated issue`);
              return;
            }
            
            const taskIssue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: nextTask.issue
            });
            
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: nextTask.issue,
              name: config.labels.task.pending
            }).catch(() => {});
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: nextTask.issue,
              labels: [config.labels.task.in_progress]
            });
            
            const customInstructions = [
              '# Task: ' + nextTask.title,
              '',
              'Parent Issue: #' + issueNumber,
              'Task ID: ' + nextTask.id,
              'Level: ' + nextTask.level,
              '',
              '## Task Description',
              '',
              taskIssue.data.body,
              '',
              '## Acceptance Criteria',
              '',
              nextTask.acceptance,
              '',
              '## Implementation Guidelines',
              '',
              '1. Follow the acceptance criteria exactly',
              '2. Write tests for your changes',
              '3. Ensure code passes lint and tests',
              '4. Keep changes focused and atomic',
              '',
              '## PR Requirements',
              '',
              '1. PR title: "[' + nextTask.id + '] ' + nextTask.title + '"',
              '2. CRITICAL: PR body MUST include these markers:',
              '   ```',
              '   Agent-Parent-Issue: ' + issueNumber,
              '   Agent-Task-Id: ' + nextTask.id,
              '   ```',
              '3. Target branch: ' + config.copilot.base_branch,
              '4. Link to task issue: #' + nextTask.issue,
              '',
              '## Risk Level: ' + nextTask.level.toUpperCase(),
              '',
              nextTask.level === 'l1' ? '- This is a low-risk task (docs/tests only)\n- Will auto-merge after CI passes' : '',
              nextTask.level === 'l2' ? '- This is a medium-risk task\n- Requires `/approve-task` command after CI passes' : '',
              nextTask.level === 'l3' ? '- This is a high-risk task\n- Requires full PR review before merge' : ''
            ].filter(line => line !== '').join('\n');
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: nextTask.issue,
              assignees: [config.copilot.bot_assignee],
              agent_assignment: {
                target_repo: `${context.repo.owner}/${context.repo.repo}`,
                base_branch: config.copilot.base_branch,
                custom_instructions: customInstructions,
                custom_agent: '',
                model: ''
              }
            });
            
            state.cursor_task_id = nextTask.id;
            state.version += 1;
            state.updated_at = new Date().toISOString();
            
            const stateComment = `${stateMarker}
\`\`\`json
${JSON.stringify(state, null, 2)}
\`\`\`

**Agent State Updated** (version ${state.version})

Phase: \`${state.phase}\`
Current Task: \`${state.cursor_task_id}\`

_This comment tracks execution state. Do not edit manually._`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: stateComment
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `ðŸš€ **Task Dispatched**\n\nAssigned task **${nextTask.id}** to ${config.copilot.bot_assignee}\n\n- **Task:** ${nextTask.title}\n- **Issue:** #${nextTask.issue}\n- **Level:** ${nextTask.level}\n\n**Status:** \`in-progress\``
            });
            
            core.info(`âœ“ Dispatched task ${nextTask.id} to Copilot`);
