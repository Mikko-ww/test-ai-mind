name: Agent Merge Policy

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull request number'
        required: true
        type: number
      parent_issue:
        description: 'Parent issue number'
        required: true
        type: number
      task_id:
        description: 'Task ID'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  evaluate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm install js-yaml minimatch

      - name: Evaluate merge policy
        id: evaluate
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const minimatch = require('minimatch');
            
            const prNumber = parseInt('${{ inputs.pr_number }}');
            const parentIssue = parseInt('${{ inputs.parent_issue }}');
            const taskId = '${{ inputs.task_id }}';
            
            const config = yaml.load(fs.readFileSync('.github/agent/config.yml', 'utf8'));
            
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const planPath = `${config.paths.plan_yaml_dir}/issue-${parentIssue}.yaml`;
            if (!fs.existsSync(planPath)) {
              core.setFailed(`Plan file not found: ${planPath}`);
              return;
            }
            
            const plan = yaml.load(fs.readFileSync(planPath, 'utf8'));
            const task = plan.tasks.find(t => t.id === taskId);
            
            if (!task) {
              core.setFailed(`Task ${taskId} not found in plan`);
              return;
            }
            
            const declaredLevel = task.level;
            
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });
            
            const changedFiles = files.map(f => f.filename);
            const maxFiles = config.merge_policy.max_changed_files_l1 || 300;
            
            let computedLevel = 'l1';
            let reason = 'All files in allowlist';
            const matchedRules = [];
            
            if (changedFiles.length > maxFiles) {
              computedLevel = 'l3';
              reason = `Too many changed files (${changedFiles.length} > ${maxFiles})`;
            } else {
              for (const file of changedFiles) {
                let matchedSensitive = false;
                let matchedAllowlist = false;
                
                for (const pattern of config.merge_policy.sensitive_globs) {
                  if (minimatch(file, pattern)) {
                    matchedSensitive = true;
                    matchedRules.push(`‚ùå ${file} ‚Üí ${pattern} (sensitive)`);
                    break;
                  }
                }
                
                if (matchedSensitive) {
                  computedLevel = 'l3';
                  reason = 'Contains sensitive file changes';
                  break;
                }
                
                for (const pattern of config.merge_policy.l1.allowlist_globs) {
                  if (minimatch(file, pattern)) {
                    matchedAllowlist = true;
                    matchedRules.push(`‚úì ${file} ‚Üí ${pattern} (allowlist)`);
                    break;
                  }
                }
                
                if (!matchedAllowlist) {
                  computedLevel = 'l2';
                  reason = 'Contains files outside allowlist';
                  matchedRules.push(`‚ö†Ô∏è ${file} (not in allowlist)`);
                }
              }
            }
            
            const finalLevel = computedLevel === 'l1' && declaredLevel !== 'l1' ? declaredLevel : 
                              computedLevel === 'l2' && declaredLevel === 'l3' ? declaredLevel :
                              computedLevel;
            
            const levelLabel = config.labels.level[finalLevel];
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: [levelLabel, config.labels.pr.task]
            });
            
            const policyComment = [
              '## üîí Merge Policy Evaluation',
              '',
              'Task: ' + taskId,
              'Declared Level: `' + declaredLevel + '`',
              'Computed Level: `' + computedLevel + '`',
              'Final Level: `' + finalLevel + '`',
              '',
              'Reason: ' + reason,
              '',
              'Changed Files: ' + changedFiles.length,
              '',
              '### File Analysis',
              '',
              matchedRules.slice(0, 20).join('\n'),
              matchedRules.length > 20 ? '\n... and ' + (matchedRules.length - 20) + ' more files' : '',
              '',
              '### Merge Requirements',
              '',
              finalLevel === 'l1' ? 'L1 - Auto-merge\n- ‚úÖ All files in allowlist\n- ‚è≥ Waiting for CI checks to pass\n- ü§ñ Will auto-merge when checks are green' : '',
              '',
              finalLevel === 'l2' ? 'L2 - Command approval required\n- ‚ö†Ô∏è Contains files outside allowlist\n- ‚è≥ Waiting for CI checks to pass\n- üë§ Requires `/approve-task` command from collaborator' : '',
              '',
              finalLevel === 'l3' ? 'L3 - Full PR review required\n- ‚ùå Contains sensitive file changes or too many files\n- ‚è≥ Waiting for CI checks to pass\n- üë• Requires full PR review approval' : ''
            ].filter(line => line !== '').join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: policyComment
            });
            
            core.setOutput('final_level', finalLevel);
            core.setOutput('can_auto_merge', finalLevel === 'l1' ? 'true' : 'false');
            
            return { finalLevel, canAutoMerge: finalLevel === 'l1' };

      - name: Enable auto-merge for L1
        if: steps.evaluate.outputs.can_auto_merge == 'true'
        uses: actions/github-script@v7
        env:
          AGENT_GH_TOKEN: ${{ secrets.AGENT_GH_TOKEN }}
        with:
          github-token: ${{ secrets.AGENT_GH_TOKEN }}
          script: |
            const prNumber = parseInt('${{ inputs.pr_number }}');
            
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash'
              });
              
              core.info('‚úì PR auto-merged (L1)');
            } catch (error) {
              if (error.status === 405 && error.message.includes('auto-merge')) {
                core.warning('Auto-merge not available, downgrading to L2');
                
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'agent:l1'
                }).catch(() => {});
                
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: ['agent:l2']
                });
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `‚ö†Ô∏è **Auto-merge Downgrade**\n\nThis PR was classified as L1 but auto-merge is not available (repository settings or branch protection).\n\n**Downgraded to L2:** Please use \`/approve-task\` command to merge.`
                });
              } else {
                core.warning(`Auto-merge failed: ${error.message}`);
              }
            }
