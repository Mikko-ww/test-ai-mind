#!/usr/bin/env node

const core = require('@actions/core');
const { initializePhases } = require('./phase-manager');

const STATE_VERSION = 16;

async function getLatestState(github, issueNumber, stateMarker) {
  try {
    const comments = await github.listComments(issueNumber);
    
    const stateComments = comments
      .filter(c => c.body && c.body.includes(stateMarker))
      .map(c => parseStateFromComment(c.body, stateMarker))
      .filter(s => s !== null);
    
    if (stateComments.length === 0) {
      return null;
    }
    
    stateComments.sort((a, b) => b.version - a.version);
    const latestState = stateComments[0];
    
    return migrateStateIfNeeded(latestState);
  } catch (error) {
    core.error(`Failed to get latest state: ${error.message}`);
    throw error;
  }
}

async function createStateComment(github, issueNumber, state, stateMarker) {
  try {
    const lines = [
      stateMarker,
      '```json',
      JSON.stringify(state, null, 2),
      '```',
      '',
      `Agent State Updated (version ${state.version})`,
      ''
    ];
    
    if (state.current_phase) {
      lines.push(`Current Phase: \`${state.current_phase}\``);
    }
    
    if (state.phase) {
      lines.push(`Legacy Phase: \`${state.phase}\``);
    }
    
    if (state.cursor_task_id) {
      lines.push(`Current Task: \`${state.cursor_task_id}\``);
    }
    
    lines.push('', '_This comment tracks execution state. Do not edit manually._');
    
    const body = lines.filter(line => line !== '').join('\n');
    return await github.createComment(issueNumber, body);
  } catch (error) {
    core.error(`Failed to create state comment: ${error.message}`);
    throw error;
  }
}

function parseStateFromComment(commentBody, stateMarker) {
  if (!commentBody || !commentBody.includes(stateMarker)) {
    return null;
  }
  
  try {
    const jsonMatch = commentBody.match(/```json\n([\s\S]*?)\n```/);
    if (jsonMatch && jsonMatch[1]) {
      return JSON.parse(jsonMatch[1]);
    }
  } catch (error) {
    core.warning(`Failed to parse state from comment: ${error.message}`);
  }
  
  return null;
}

function migrateStateIfNeeded(state) {
  if (!state) {
    return null;
  }
  
  if (state.version >= STATE_VERSION) {
    return state;
  }
  
  core.info(`Migrating state from version ${state.version} to ${STATE_VERSION}`);
  
  const migratedState = { ...state };
  
  if (!migratedState.phases) {
    migratedState.phases = initializePhases();
    
    if (migratedState.phase) {
      const legacyPhaseMap = {
        'spec-in-progress': 'requirement',
        'plan-in-progress': 'spec',
        'executing': 'execution'
      };
      
      migratedState.current_phase = legacyPhaseMap[migratedState.phase] || 'requirement';
    } else {
      migratedState.current_phase = 'requirement';
    }
  }
  
  if (!migratedState.current_phase) {
    migratedState.current_phase = 'requirement';
  }
  
  migratedState.version = STATE_VERSION;
  migratedState.updated_at = new Date().toISOString();
  
  return migratedState;
}

function createInitialState(issueNumber, owner, repo) {
  return {
    state_id: `agent-state:${owner}/${repo}:${issueNumber}`,
    version: STATE_VERSION,
    parent_issue: issueNumber,
    current_phase: 'requirement',
    phases: initializePhases(),
    plan_path: null,
    cursor_task_id: null,
    tasks: {},
    paused: false,
    phase: 'requirement-in-progress',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
}

module.exports = {
  STATE_VERSION,
  getLatestState,
  createStateComment,
  parseStateFromComment,
  migrateStateIfNeeded,
  createInitialState
};

      
      migratedState.current_phase = legacyPhaseMap[migratedState.phase] || 'requirement';
    } else {
      migratedState.current_phase = 'requirement';
    }
  }
  
  if (!migratedState.current_phase) {
    migratedState.current_phase = 'requirement';
  }
  
  migratedState.version = STATE_VERSION;
  migratedState.updated_at = new Date().toISOString();
  
  return migratedState;
}

function createInitialState(issueNumber, owner, repo) {
  return {
    state_id: `agent-state:${owner}/${repo}:${issueNumber}`,
    version: STATE_VERSION,
    parent_issue: issueNumber,
    current_phase: 'requirement',
    phases: initializePhases(),
    plan_path: null,
    cursor_task_id: null,
    tasks: {},
    paused: false,
    phase: 'requirement-in-progress',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
}

module.exports = {
  STATE_VERSION,
  getLatestState,
  createStateComment,
  parseStateFromComment,
  migrateStateIfNeeded,
  createInitialState
};
